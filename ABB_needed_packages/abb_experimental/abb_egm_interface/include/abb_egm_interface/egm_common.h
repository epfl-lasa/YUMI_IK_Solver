/***********************************************************************************************************************
 *
 * Software License Agreement (BSD License)
 *
 * Copyright (c) 2015, ABB
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with
 * or without modification, are permitted provided that
 * the following conditions are met:
 *
 *    * Redistributions of source code must retain the
 *      above copyright notice, this list of conditions
 *      and the following disclaimer.
 *    * Redistributions in binary form must reproduce the
 *      above copyright notice, this list of conditions
 *      and the following disclaimer in the documentation
 *      and/or other materials provided with the
 *      distribution.
 *    * Neither the name of ABB nor the names of its
 *      contributors may be used to endorse or promote
 *      products derived from this software without
 *      specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ***********************************************************************************************************************
 */

#ifndef EGM_COMMON_H
#define EGM_COMMON_H

#define _USE_MATH_DEFINES

#include <math.h>
#include <queue>

#include "egm_interface.pb.h" // Generated by Google protoc.exe

#ifdef linux
#include <ros/ros.h>
#include <control_msgs/FollowJointTrajectoryAction.h>
#endif

namespace abb
{
namespace egm_interface
{
/****************************************************************************************
 * Default values
 */

namespace egm_common_values
{
namespace robot_controller
{
/**
 * \brief Lowest sample time [s] used in EGM communication.
 */
static const double LOWEST_SAMPLE_TIME = 0.004;

/**
 * \brief Default number of robot joints.
 */
static const size_t DEFAULT_NUMBER_OF_ROBOT_JOINTS = 6;

/**
 * \brief Default number of external joints.
 */
static const size_t DEFAULT_NUMBER_OF_EXTERNAL_JOINTS = 6;

/**
 * \brief Maximum number of joints.
 */
static const size_t MAX_NUMBER_OF_JOINTS = DEFAULT_NUMBER_OF_ROBOT_JOINTS + DEFAULT_NUMBER_OF_EXTERNAL_JOINTS;
}

namespace communication
{
/**
 * \brief Default port number.
 */
static const size_t DEFAULT_PORT_NUMBER = 6511;
}

namespace interpolation
{
/**
 * \brief Default speed limit [deg/s] for the simple joint and rotation interpolation.
 *
 * Note: Only used when NO duration has been specified.
 */
static const double DEFAULT_JOINT_SPEED_LIMIT = 1.0;

/**
 * \brief Default acceleration limit [deg/s^2] for the simple joint and rotation interpolation.
 *
 * Note: Only used when NO duration has been specified.
 */
static const double DEFAULT_JOINT_ACCELERATION_LIMIT = 1.0;

/**
 * \brief Default speed limit [mm/s] for the simple Cartesian position interpolation.
 *
 * Note: Only used when NO duration has been specified.
 */
static const double DEFAULT_CARTESIAN_SPEED_LIMIT = 1.0;

/**
 * \brief Default acceleration limit [mm/s^2] for the simple Cartesian position interpolation.
 *
 * Note: Only used when NO duration has been specified.
 */
static const double DEFAULT_CARTESIAN_ACCELERATION_LIMIT = 1.0;

/**
 * \brief Default maximum time interval [s] for the simple interpolation (used when NO duration has been set).
 */
static const double DEFAULT_MAX_T = 15.0;

/**
 * \brief Default ramp down time [s].
 */
static const double DEFAULT_RAMP_DOWN_TIME = 1.0;
}

namespace logging
{
/**
 * \brief Default maximum logging time [s].
 */
static const double DEFAULT_MAX_LOGGING_TIME_MAX = 120.0;
}

namespace conditions
{
/**
 * \brief Default condition for when a point is considered to have been reached.
 */
static const double DEFAULT_CONDITION = 4.0;

/**
 * \brief Default condition for when a fine point is considered to have been reached.
 */
static const double DEFAULT_FINE_CONDITION = 0.01;
}

namespace conversions
{
/**
 * \brief Conversion value from radians to degrees.
 */
static const double RAD_TO_DEG = 180.0 / M_PI;

/**
 * \brief Conversion value from degrees to radians.
 */
static const double DEG_TO_RAD = M_PI / 180.0;

/**
 * \brief Conversion value from millimeter to meter.
 */
static const double MM_TO_M = 0.001;

/**
 * \brief Conversion value from milliseconds to seconds.
 */
static const double MS_TO_S = 0.001;
}
}




/****************************************************************************************
 * Support structures and classes
 */

/**
 * \brief A struct for an EGM server's data.
 */
struct EGMServerData
{
  /**
   * \brief A default constructor.
   */
  EGMServerData();

  /**
   * \brief Port number for the server's UDP socket.
   */
  size_t port_number;

  /**
   * \brief The recieved message.
   */
  std::string message;

  /**
   * \brief Bytes transferred to the server.
   */
  size_t bytes_transferred;
};

/**
 * \brief A struct for an EGM interface's configuration.
 */
struct EGMInterfaceConfiguration
{
  /**
   * \brief An enum for the number of axes of the robot.
   */
  enum RobotAxes
  {
    Six = 6,  ///< \brief A six axes robot.
    Seven = 7 ///< \brief A seven axes robot.
  };

  /**
   * \brief An enum for the EGM modes the interface can use.
   */
  enum InterfaceModes
  {
    EGMJoint,    ///< \brief Use the EGM joint mode.
    EGMCartesian ///< \brief Use the EGM Cartesian mode.
  };

  /**
   * \brief An enum for the available spline interpolation methods.
   */
  enum SplineMethod
  {
    Linear, ///< \brief Use a first degree polynomial.
    Cubic,  ///< \brief Use a third degree polynomial
    Quintic ///< \brief Use a fifth degree polynomial.
  };
  
  /**
   * \brief An enum for the available execution modes.
   */
  enum ExecutionModes
  {
    Demo,      ///< \brief Use demo references (for testing the communication).
    Direct,    ///< \brief Use direct references from a user (e.g. from an external controller).
    Trajectory ///< \brief Use trajectory references from a user (e.g. execute precalculated trajectories).
  };

  /**
   * \brief A struct for the interface's basic settings.
   */
  struct BasicSettings
  {
    /**
     * \brief A default constructor.
     */
    BasicSettings();

    /**
     * \brief A value specifying if a six or seven axes robot is used.
     */
    RobotAxes axes;

    /**
     * \brief Flag indicating if conditions should be used.
     *
     * Note: If the provided trajectroies contain intermediate points of 4 ms interval,
     * then the condition for when a point is reached might not be required.
     */
    double use_conditions;
    
    /**
     * \brief Value indicating what execution mode the interface should use.
     *
     * ExecutionModes::Demo for testing communication.
     * ExecutionModes::Direct for setting references from e.g. an external controller.
     * ExecutionModes::Trajectory for executing precalculated trajectories.
     */
    ExecutionModes execution_mode;
  };

  /**
   * \brief A struct for the interface's communication settings.
   */
  struct CommunicationSettings
  {
    /**
     * \brief A default constructor.
     */
    CommunicationSettings();

    /**
     * \brief Flag indicating if position values should be used when sending messages to the robot controller.
     */
    bool use_position;

    /**
     * \brief Flag indicating if speed values should be used when sending messages to the robot controller.
     */
    bool use_speed;
  };

  /**
   * \brief A struct for speed and acceleration limits (used in the interpolation, when the time interval is unknown).
   */
  struct Limits
  {
    /**
     * \brief A constructor.
     */
    Limits(double speed_limit, double acceleration_limit);

    /**
     * \brief Speed limit for the simple interpolation.
     */
    double speed;

    /**
     * \brief Acceleration limit for the simple interpolation.
     */
    double acceleration;
  };

  /**
   * \brief A struct for the interface's simple interpolation settings.
   */
  struct SimpleInterpolationSettings
  {
    /**
     * \brief A default constructor.
     */
    SimpleInterpolationSettings();

    /**
     * \brief Flag indicating if simple interpolation should be used.
     *
     * Note: If the provided trajectroies contain intermediate points of 4 ms interval,
     * then interpolation might not be required.
     */
    bool use_interpolation;

    /**
     * \brief A value specifying which spline method to use.
     */
    SplineMethod spline_method;

    /**
     * \brief Flag indicating if speed input values should be used in the interpolation.
     *        If using cubic or quintic polynomials and flag is false, then zero speed is assumed as end target.
     */
    bool use_speed;

    /**
     * \brief Flag indicating if acceleration input values should be used in the interpolation.
     *        If using quintic polynomials and flag is false, then zero acceleration is assumed as end target.
     */
    bool use_acceleration;

    /**
     * \brief Limits for the simple joint interpolation (used when the time interval is unknown).
     */
    Limits joint_limits;

    /**
     * \brief Limits for the simple Cartesian interpolation (used when the time interval is unknown).
     */
    Limits cartesian_limits;

    /**
     * \brief Maximum time interval for the simple interpolation (used when the time interval is unknown).
     */
    double max_T;

    /**
     * \brief Ramp down time.
     */
    double ramp_down_time;
  };

  /**
   * \brief A struct for the interface's logging settings.
   */
  struct LoggingSettings
  {
    /**
     * \brief A constructor.
     */
    LoggingSettings();

    /**
     * \brief Flag indicating if the interface should log data.
     */
    bool use_logging;

    /**
     * \brief A maximum time [s] to log data.
     */
    double max_time;
  };

  /**
   * \brief The interface's basic settings.
   */
  BasicSettings basic;

  /**
   * \brief The interface's communication settings.
   */
  CommunicationSettings communication;

  /**
   * \brief The interface's simple interpolation settings.
   */
  SimpleInterpolationSettings simple_interpolation;

  /**
   * \brief The interface's logging settings. I.e. logging of robot messages and reference values sent to the robot.
   */
  LoggingSettings logging;
};

/**
 * \brief A struct for a trajectory containing the points the robot should pass through.
 */
class EGMTrajectory
{
public:
  /**
   * \brief A default constructor.
   */
  EGMTrajectory() {}

  /**
   * \brief A constructor.
   *
   * param trajectory for parsing a proto::Trajectory message.
   */
  EGMTrajectory(const proto::Trajectory trajectory);

  #ifdef ROS_VERSION
  /**
   * \brief A constructor.
   *
   * param goal for parsing a control_msgs::FollowJointTrajectoryGoal goal.
   */
  EGMTrajectory(const control_msgs::FollowJointTrajectoryGoal goal);
  #endif

  /**
   * \brief A method for adding a point to the front of the queue.
   *
   * \param point to store.
   */
  void addTrajectoryPointFront(proto::TrajectoryPoint point);

  /**
   * \brief A method for adding a point to the back of the queue.
   *
   * \param point to store.
   */
  void addTrajectoryPointBack(proto::TrajectoryPoint point);

  /**
   * \brief A method to retrive a point from the queue.
   *
   * \param p_point for storing the retrived point.
   *
   * \return bool indicating if a point was retrived.
   */
  bool retriveNextTrajectoryPoint(proto::TrajectoryPoint* p_point);

  /**
   * \brief A method to copy the whole queue to a trajectory container.
   *
   * \param p_trajectory for containing the queue.
   */
  void copyTo(proto::Trajectory* p_trajectory);

private:
  /**
   * \brief A method to check if a point is valid to put into the queue.
   *
   * \param p_point to check.
   *
   * \return bool indicating if a point is ok to store.
   */
  bool checkPoint(proto::TrajectoryPoint* p_point);

  /**
   * \brief Container for the points in the trajectory.
   */
  std::deque<proto::TrajectoryPoint> points_;
};

} // end namespace egm_interface
} // end namespace abb

#endif // EGM_COMMON_H