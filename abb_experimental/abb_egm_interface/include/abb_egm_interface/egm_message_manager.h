/***********************************************************************************************************************
 *
 * Software License Agreement (BSD License)
 *
 * Copyright (c) 2015, ABB
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with
 * or without modification, are permitted provided that
 * the following conditions are met:
 *
 *    * Redistributions of source code must retain the
 *      above copyright notice, this list of conditions
 *      and the following disclaimer.
 *    * Redistributions in binary form must reproduce the
 *      above copyright notice, this list of conditions
 *      and the following disclaimer in the documentation
 *      and/or other materials provided with the
 *      distribution.
 *    * Neither the name of ABB nor the names of its
 *      contributors may be used to endorse or promote
 *      products derived from this software without
 *      specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ***********************************************************************************************************************
 */

#ifndef EGM_MESSAGE_MANAGER_H
#define EGM_MESSAGE_MANAGER_H

#include <fstream>
#include <memory>

#include <boost/shared_ptr.hpp>

#include "egm.pb.h"                     // Generated by Google protoc.exe

#include "egm_common.h"

namespace abb
{
namespace egm_interface
{
/**
 * \brief A class for managing different types of EGM messages.
 */
class EGMMessageManager
{
public:
  /**
   * \brief An enum for the EGM message types that the class can handle.
   */
  enum MessageTypes
  {
    EGM ///< Use the EGM messages.
  };

  /**
   * \brief A struct for containing the EGM messages.
   */
  struct MessageContainer
  {
    /**
     * \brief A constructor.
     *
     * \param type for specifying used type of the EGM messages.
     */
    MessageContainer(MessageTypes type);

    /**
     * \brief A destructor.
     */
    ~MessageContainer() {}

    /**
     * \brief Container for EGMRobot (robot output message).
     */
    boost::shared_ptr<abb::egm::EgmRobot> p_egm_robot_;

    /**
     * \brief Container for EGMSensor (robot input message).
     */
    boost::shared_ptr<abb::egm::EgmSensor> p_egm_sensor_;

    /**
     * \brief Used type of EGM messages.
     */
    MessageTypes type_;
  };

  /**
   * \brief A constructor.
   *
   * \param axes for specifying how many axes the robot has.
   * \param settings for the message manager's communication settings.
   * \param type for specifying used type of the EGM messages.
   */
  EGMMessageManager(const EGMInterfaceConfiguration::RobotAxes axes,
                    const EGMInterfaceConfiguration::CommunicationSettings settings,
                    const MessageTypes type = EGM);

  /**
   * \brief A destructor.
   */
  ~EGMMessageManager() {}

  /**
   * \brief Parse a string containing a recieved EGM message.
   *
   * \param data containing the recieved data as a string.
   * \param bytes_transferred for number of bytes recieved in the message.
   */
  void parseFromString(const std::string data, const int bytes_transferred);

  /**
   * \brief Serialize an EGM output message and put the result in a string.
   *
   * \return std::string containing the serialized EGM message.
   */
  std::string serializeToString();

  /**
   * \brief Updates the message manager's settings.
   *
   * \param axes for specifying how many axes the robot has.
   * \param settings for the message manager's communication settings.
   */
  void updateSettings(const EGMInterfaceConfiguration::RobotAxes axes,
                      const EGMInterfaceConfiguration::CommunicationSettings settings);

  /**
   * \brief Construct an EGM reply.
   *
   * \param sequence_number of the output message.
   * \param target containing the targeted point for the robot.
   */
  void constructReply(const size_t sequence_number, proto::TrajectoryPoint target);

  /**
   * \brief Check if it is the first message recieved from the robot.
   *
   * \return bool indicating if it is the first message.
   */
  bool isFirstMessage();

  /**
   * \brief Retrive the timestamp of the recieved message.
   *
   * \return size_t specifying the recieved message's timestamp.
   */
  size_t getTimestamp();

  /**
   * \brief Retrive the recieved robot feedback values.
   *
   * \return proto::Feedback containing the feedback values.
   */
  proto::Feedback getRobotFeedback();

  /**
   * \brief Retrive the recieved robot planned values.
   *
   * \return proto::Planned containing the planned values.
   */
  proto::Planned getRobotPlanned();

  /**
   * \brief Retrive the recieved robot feedback values (in joint space).
   *
   * \return proto::JointSpace containing the feedback values (joint positions).
   */
  proto::JointSpace getJointSpaceRobotFeedbackPosition();

  /**
   * \brief Retrive the recieved robot planned values (in joint space).
   *
   * \return proto::JointSpace containing the planned values (joint positions).
   */
  proto::JointSpace getJointSpaceRobotPlannedPosition();

  /**
   * \brief Retrive the recieved robot feedback values (in Cartesian space).
   *
   * \return proto::CartesianSpace containing the feedback values (TCP position and orientation).
   */
  proto::CartesianSpace getCartesianSpaceRobotFeedbackPosition();

  /**
   * \brief Retrive the recieved robot planned values (in Cartesian space).
   *
   * \return proto::CartesianSpace containing the planned values (TCP position and orientation).
   */
  proto::CartesianSpace getCartesianSpaceRobotPlannedPosition();

  /**
   * \brief Retrive the recieved robot controller's status.
   *
   * \return proto::RobotStatus containing the robot controller's status.
   */
  proto::RobotStatus getRobotStatus();

  /**
   * \brief Log robot feedback and planned values as well as server output references into a CSV file.
   *
   * \param log_stream stream object.
   * \param target containing the targeted point for the robot.
   */
  void logData(std::ofstream& log_stream, const proto::TrajectoryPoint target);

private:
  /**
   * \brief Parse EGM joint message.
   *
   * \param joints containing the recieved robot axes data.
   * \param external_joints containing the recieved external axes data.
   *
   * \return proto::JointSpace containing the parsed data.
   */
  proto::JointSpace parseJoints(const abb::egm::EgmJoints joints, const abb::egm::EgmJoints external_joints);

  /**
   * \brief Parse EGM pose message.
   *
   * \param pose containing the recieved pose data.
   *
   * \return proto::CartesianSpace containing the parsed data.
   */
  proto::CartesianSpace parsePose(const abb::egm::EgmPose pose);

  /**
   * \brief Construct the header of an EGM reply.
   *
   * \param sequence_number of the output message.
   * \param timestamp of the output message.
   */
  void constructReplyHeader(const size_t sequence_number, const size_t timestamp);

  /**
   * \brief Construct the body of an EGM joint space reply (for EGM's joint mode).
   *
   * \param target containing the targeted joint space point for the robot.
   */
  void constructReplyJointSpaceBody(const proto::JointSpace target);

  /**
   * \brief Construct the body of an EGM Cartesian space reply (for EGM's pose mode).
   *
   * \param target containing the targeted Cartesian space point for the robot.
   */
  void constructReplyCartesianSpaceBody(const proto::CartesianSpace target);

  /**
   * \brief Add joint data to the log stream.
   *
   * \param log_stream stream object.
   * \param joints containing the joint data to add.
   */
  void logDataAddJoints(std::ofstream& log_stream, const egm::EgmJoints joints);

  /**
   * \brief Add joint data to the log stream.
   *
   * \param log_stream stream object.
   * \param joints containing the joint data to add.
   */
  void logDataAddJoints(std::ofstream& log_stream, const proto::JointSpace joints);

  /**
   * \brief Add mock values for missing joint data to the log stream.
   *
   * \param log_stream stream object.
   * \param size of the previous joint container.
   */
  void logDataAddMockJoints(std::ofstream& log_stream, const size_t size);

  /**
   * \brief Container for the EGM messages (both input and output).
   */
  MessageContainer message_;

  /**
   * \brief Indicates how many axes the robot has (a remapping is done for seven axes robots).
   */
  EGMInterfaceConfiguration::RobotAxes axes_;

  /**
   * \brief The communication settings.
   */
  EGMInterfaceConfiguration::CommunicationSettings settings_;
};

} // end namespace egm_interface
} // end namespace abb

#endif // EGM_MESSAGE_MANAGER_H
